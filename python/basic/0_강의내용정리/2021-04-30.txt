웹드라이버 필요함. 웹을 주물주물? 할 수 있는것. 이라는듯.

크롬브라우저 버전을 알아야함.
버전이 같아야한단것.
Chrome이 최신 버전입니다.
버전 90.0.4430.93(공식 빌드) (64비트)


https://chromedriver.chromium.org/downloads

버전은 상위호환은 되는데 하휘호환은 안됨. ? 그 반대아님? 
아무튼간에 그렇기에 크롬과 버전을 일치시켜서 받아야함.

64 : 64차선. 데이터를 한 번에 64개를 병렬로 들여옴
32 : 차선 32개.

다운로드된 드라이버는
디폴트 경로에 넣을거임
C:/사용자/주피터 강의 파일에 넣을거임
C:/에 넣는게 가장편함


원하는 함수만 import하는이유는
메모리 낭비를 줄이기 위함임.


기초.
---------------------------------------------------------------------------
T2:
기사
-------------------------------------------------------
T3 : 실시간 검색어
사라져서 지금은 할 수 없음.

https://datalab.naver.com/home/sectionSearch.naver

https://datalab.naver.com/keyword/realtimeList.naver?where=main

resultset의 데이터형이면 변수명[0]으로 작성
print(date[0].text)
date_com = date[0].text
time_com = "%시 %s분 %s초" %(now.hour, now.minute, now.second)
print(date_com, time_com)


# 랭킹 가져옴.
# ranking list에 해당하는걸 가져옴(클래스명)
search_all = html_parsing.select("ul.ranking_list > li.ranking_item")
print(search_all)

for search_one in search_all:
    num = search_one.find("span", {"class" : "item_num"})
    # 등수가져오기
#    print(num)
#  1 ~ 20 랭킹에 해당하는 숫자 출력됨
#    print(num.text + "등 : ")
    num_com = num.text + "등 :"
    keyword = search_one.find("span", {"class" : "item_title"})
#    print(keyword)
    # 등수에 해당하는 검색어 순위가 뜸
#    print(keyword.text)
    keyword_com = keyword.text
    print(num_com, keyword_com)


# 아까 시간건드릴때 변수임ㅇㅇ 
print(date_com, time_com)
print()
# 위에 랭킹에 해당하는거 긁어서 넣어주면 시간(날짜 현재시각)과 랭킹에 해당하는게 출력됨.

----------------------------
naver_crawling_realtime_search_environment

셀레늄에서 element에 접근하는 메소드
셀레늄 문법.
find_element_by_   +
(
id(id)
class_name(name)
name(name)
css_selector(query)
- 밑(하위)으로 내려갈 수 있는구조로 되어있음. > 사용가능. 
xpath(query)
- 버튼에 해당하는것에 많이 사용
tag_name(name)
- p태그, div태그 등
link_text(text)
- 링크 텍스트(하이퍼링크) 하나 추출
partial_link_text(text)
)
query에 해당하는것들은 많이 사용하는것들임
e.g. find_element_by_id(id속성)

우클릭, copy, xpath.
메모장 :
10대 //*[@id="content"]/div/div[2]/div[1]/div[2]/div/div/div/ul/li[1]
10대 버튼의 태그들의 절대경로임
[2] 같은건, 해당 태그의 요소의 인덱스.
같은 라인에 같은 태그가 여러개 존재할 시 인덱스로 구분.

20대 : //*[@id="content"]/div/div[2]/div[1]/div[2]/div/div/div/ul/li[2]

30대 : //*[@id="content"]/div/div[2]/div[1]/div[2]/div/div/div/ul/li[3]

나이대 버튼의 요소가 li형식으로 나란히 들어가있음. 배열의 형태로.

input("안내메세지 탑재가능")
num = input("10대 1, 20대 2, 30대 3, 40대 4, 50대 5, 전체 6의 숫자를 입력해주세요:")
//*[@id="content"]/div/div[2]/div[1]/div[2]/div/div/div/ul/li[num]

해당패스가 문자열의 형태이므로 
"//*[@id="content"]/div/div[2]/div[1]/div[2]/div/div/div/ul/li["+num+"]" 형태로 적어야 할 수 잇음


릴타임아이템서치의 버튼을 페이지와 검색 사이에 두어야함.

----------------------------------------------------------------------------------
T5:
셀레늄 파트 마무리.

xpath 쪽을 배우는게 좋다.


이미지 자동으로 쫘롸롸롹 가져오기ㅇㅇ

1. 페이지 들어가자마자 업로드된 이미지 추출
2. 스크롤내렸을때, 서버에서 올라오는 이미지 추출

이미지 추출에 어느정도의 시간이 걸리는지?


-------------
네이버의 이미지 검색패턴
https://search.naver.com/search.naver?sm=tab_hty.top&where=image&query=검색할내용


------------------------------------------------------------------------------------------
T6 : 모두의 딥러닝
최소제곱법

제곱을 함으로서 오차를 더 쉽게 파악가능.
오차를 넓게 퍼뜨려 오차를 더 쉽게 볼 수 있도록. 돋보이도록

오늘 나갈것:

평균제곱 오차
mean square error : MSE

최소제곱법 - 가장 훌륭한 직선. 
여러 입력 처리하기 힘듦. 입력값 여러개인 상황?
여러개 입력 계산. 임의선 그리고 얼마나 잘 그렸는지 평가하면서 조금씩 수정하는 방법사용.
주어진 선의 오차를 평가하는 알고리즘으로 가장 많이 사용하는게 MSE임.



1. 잘못그은 선 바로잡기.
기울기 a, y절편 b 찾으려고 최소제곱법 사용했음.
이때 변수는 1개뿐일때였음. 여러개 입력변수를 다룰때는 기울기와 절편을 찾아내는 방법이 달라야함.

이 때 가장 많이 사용하는 방법이 '일단 그리고 조금씩 수정해나가는 방식'임. 가중치를 두면서 그것에 따라 조금씩 수정하는 방식임.

값이 주어진 요건 충족하는지 조금씩 변화 주고, 변화가 긍정적이면 오차가 최소가 될 때 까지 과정 반복하는 방법. 딥러닝을 가능하게 하는 가장 중요한 원리 중 하나임.

나중에 그린 선이 이전 선보다 더 좋은지 나쁜지 판단.
각 선의 오차를 계산할 수 있어야 하며, 오차가 작은 쪽으로 바꾸는 알고리즘 필요. 

오차계산방법?
최소제곱법을 통해 그림을 그릴 때, y = 2.3x + 79였음.
예상)오차란건 선을 기준으로 데이터들이 떨어진 값의 총 합이 아닐까? 그러니까 그 거리들의 제곱의 합? 
오차정도를 확인 : 직선과 데이터 사이의 거리를 재면 됨.
합이 적을수록 직선이 잘 그려진것. 합이 클수록 잘못그려진 직선임.

기울기가 무한대로 커지면, 오차도 무한대로 커지는 상관관계가 있음. 

거리 : 입력데이터에 나와있는 y의 실제값과 직선의 방정식에 대입한 예측값의 차이를 통해 구함.
y=3x+76 에 공부시간인 x = 2를 대입했을 때, 예측된 점수의 결과값이 82점이라면, 실제값은 81이었기에, 오차는 1임.


오차의 총합이 작으면 작을수록 잘 예측한것.
오차의 총합이 크면클수록 
오차 : 실제 얼마나 큰지 가늠하기 힘듦. 전부 더하면 0이 될 수도 있기때문에 부호를 없애기 위해 오차값을 제곱함.
예측값-실제값
오차합은 i부터 n까지 시그마(y_i-y헷_i)^2임.
예상 ) 와~~~ 맞췄다 헤헤헤헿 서당개 삼년이면 풍월을 읊는다굽
i : x 순서, n : x 총 개수, y_i : 실제값, 
이렇게 구한 값을 n으로 나누어 오차 합의 평균을 구할 수 있음.

MSE = 1/nSigma(y_i-y헷)^2



평균제곱오차의 계산 결과가 가장 작은 값을 그리는게 MSE.
코딩으로 확인해보자. ? 이거 언제적엇

-------------------------------------------------------------------------------------
T7 : 코딩으로 확인하는 평균제곱오차
R 머신러닝이나 파이썬 머신러닝이나 개념은 같으니까 그냥 알아두는게 좋음ㅇㅇ

predict() 를 활용해서 일차방정식 y = ax+b구현.
x : 시간, y = 점수.

----------------------------------------------------------------------------------------------------

과제 : 
1. 구글 로그인 
보안 2단계에서 1단계로 내려야함.
(보안2단계 : 폰 번호 누르는게 나옴)
셀레늄을 통해 버튼 누르기(xPath, Click)
해서 로그인 하는것 인증.

2. 다음 이미지 크롤링. 블랙핑크
스크롤 2~3번 내릴 정도로
키워드 입력받을 수 있도록. 키워드는 자유지만,
이미지 tqdm패키지 사용. 프로그래스바 보이게
폴더 생성. format 혹은 f-string 사용해서 저장


노션하실분은 버튼누르는거 해보쇼
노션은 하던가 말던가ㅇㅇ

노션페이지 크롤링
교수님 아마도 일주일에 한 번 씩은 노션링크 확인하시는듯. 그러니까 주말 되기전에 정리해놓자. 바부야.
왜 맨날 미루냐. 미루는것도 미루는건데 일단 해두자고.
바부야.

